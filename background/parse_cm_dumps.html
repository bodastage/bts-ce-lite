<h1>Background process</h1>
<script type="text/javascript">
	
const {ipcRenderer} = window.require('electron');
const { app, process } = window.require('electron').remote;
const { spawn } = window.require('child_process') 
const path = window.require('path')
const isDev = window.require('electron-is-dev');
const replace = window.require('replace-in-file');


const VENDOR_PARSERS = {
	'ERICSSON': {
		'BULKCM': 'boda-bulkcmparser.jar',
		'CNAIV2': 'boda-ericssoncnaiparser.jar',
	},
	'HUAWEI': {
		'GEXPORT_XML': 'boda-huaweicmobjectparser.jar',
		'CFGMML': 'boda-huaweimmlparser.jar',
		'NBI_XML': 'boda-huaweicmxmlparser.jar'
	},
	'ZTE': {
		'BULKCM': 'boda-bulkcmparser.jar',
		'XLS': 'boda_ztexlscmparser.jar',
	},
	'NOKIA': {
		'RAML': 'boda-nokiacmdataparser.jar'
	}
}

/**
* Clean Huawei GExport files.
*
*	sed -i -r "
*	s/_(BSC6900GSM|BSC6900UMTS|BSC6900GU|BSC6910GSM|BSC6910UMTS|BSC6910GU)//ig;
*	s/_(BTS3900|PICOBTS3900|BTS3911B|PICOBTS3911B|MICROBTS3900|MICROBTS3911B)//ig;
*	s/BSC(6910|6900)(UMTS|GSM)Function/FUNCTION/ig;
*	s/BSC(6910|6900)Equipment/EQUIPMENT/ig;
*	s/<class name=\"(.*)\"/<class name=\"\U\1\"/ig;
*	s/<class name=\"(.*)_MSCSERVER/<class name=\"\1/ig;
*	s/<class name=\"(.*)_ENODEB\"/<class name=\"\1\"/ig;
*	s/<class name=\"(.*)3900/<class name=\"\1/ig;
*	" /mediation/data/cm/huawei/raw/gexport/*.xml
*
* @exportFolder String Folder with the GExport dump XML files to be cleaned
*/
cleanHuaweiGexportFiles = (exportFolder) => {	
	const replaceOptions = {
	  files: path.join(exportFolder,'*'),
	  from: [
		/_(BSC6900GSM|BSC6900UMTS|BSC6900GU|BSC6910GSM|BSC6910UMTS|BSC6910GU)/ig,
		/_(BTS3900|PICOBTS3900|BTS3911B|PICOBTS3911B|MICROBTS3900|MICROBTS3911B)/ig,
		/BSC(6910|6900)(UMTS|GSM)Function/ig,
		/BSC(6910|6900)Equipment/ig,
		/<class name=\"(.*)\"/ig,
		/<class name=\"(.*)_MSCSERVER/ig,
		/<class name=\"(.*)_ENODEB\"/ig,
		/<class name=\"(.*)3900/
	  ],
	  to: [
		"",
		"",
		"FUNCTION",
		"EQUIPMENT",
		(matchStr) => "<class name=\"" + matchStr.match(/<class name=\"(.*)\"/)[1].toUpperCase() + "\"",
		(matchStr) => "<class name=\"" + matchStr.match(/<class name=\"(.*)_MSCSERVER/)[1],
		(matchStr) => "<class name=\"" + matchStr.match(/<class name=\"(.*)_ENODEB\"/)[1] + "\"",
		(matchStr) => "<class name=\"" + matchStr.match(/<class name=\"(.*)3900/)[1]
	  ],
	};
	
	return replace.sync(replaceOptions)
    
}


/*
* Take the latest file when there is more than one file from the same node .
*
8 @param pathToFolder The name of the folder containing the GExport XML CM dumps
*/
removeDublicateHuaweiGExportFiles = (pathToFolder) => {
	const fs = window.require('fs');
	
	ipcRenderer.send('parse-cm-job', JSON.stringify({status:"info", message: "Starting removal of duplicate gexport files..."}))
	
	//Key - value pair of node and the most recent file
	let nodeAndRecentFile = {}
	
	fs.readdirSync(pathToFolder, function(err, items) {
		
		for (var i=0; i<items.length; i++) {
			const gexportFilename = items[i];
			const matches = gexportFilename.match(/(.*)_(\d+)\.xml/)
			
			ipcRenderer.send('parse-cm-job', JSON.stringify({status:"info", message: `Checking whether ${gexportFilename} is a duplicate... `}))
			
			if(matches === null) return 
			
			const node = matches[1]
			const timestamp = matches[2]
			
			if( typeof nodeAndRecentFile[node] === 'undefined'){
				nodeAndRecentFile[node] = gexportFilename
			}else{
				//Get timestamp on file in nodeAndRecentFile
				const mostRecentTimestamp = nodeAndRecentFile[node].match(/(.*)_(\d+)\.xml/)[2]
				
				if(parseInt(timestamp) > parseInt(mostRecentTimestamp)){
					
					//Delete the oldfile 
					fs.unlinkSync(path.join(pathToFolder, nodeAndRecentFile[node]))
					
					nodeAndRecentFile[node] = gexportFilename

				}
				
			}
		}
	});
	
	ipcRenderer.send('parse-cm-job', JSON.stringify({status:"info", message: `Duplicate file removal completed.`}))
	
}


processCMDumps = (vendor, format, inputFolder, outputFolder) => {
	let basepath = app.getAppPath();

	if (!isDev) {
	  basepath = process.resourcesPath
	} 
	
	const parser = VENDOR_PARSERS[vendor][format]
	const parserPath = path.join(basepath,'libraries',parser)
	
	//Clean Huawei GExport files 
	if(vendor === 'HUAWEI' && format === 'GEXPORT_XML'){
		try{
			removeDublicateHuaweiGExportFiles(inputFolder)
			
			ipcRenderer.send('parse-cm-job', JSON.stringify({status:"info", message: `Cleaning GExport XML files...`}))
			cleanHuaweiGexportFiles(inputFolder)

			ipcRenderer.send('parse-cm-job', JSON.stringify({status:"info", message: `Cleanup of GExport XML files completed.`}))
			
		}catch(error){
			ipcRenderer.send('parse-cm-job', JSON.stringify({status:"error", message: error}))
			return;
		}
		
	}
	
	ipcRenderer.send('parse-cm-job', JSON.stringify({status:"info", message: `Parsing files...`}))
	
	const child = spawn('java', ['-jar', parserPath, '-i',inputFolder,'-o',outputFolder]);
	
	child.stdout.on('data', (data) => {
	  //console.log(data.toString());
	});

	child.stderr.on('data', (data) => {
	  ipcRenderer.send('parse-cm-job', JSON.stringify({status:"error", message: data.toString()}))
	});
	
	child.on('exit', code => {
		if(code === 0 ){
			ipcRenderer.send('parse-cm-job', JSON.stringify({status:"success", message: `Dump successfully parsed. Find csv files in ${outputFolder}`}))
		}else{
			ipcRenderer.send('parse-cm-job', JSON.stringify({status:"error", message: "Something went wrong"}))
		}
	});

}
	
function log(value) {
	ipcRenderer.send('to-main', process.pid + ': ' + value);
}

ipcRenderer.on('parse-cm-job', (event, args) => {
	
	const obj  = JSON.parse(args)
	
	processCMDumps(obj.vendor, obj.format, obj.inputFolder, obj.outputFolder)
})

ipcRenderer.send('ready')

</script>